#ifndef MESSAGES_HPP
#define MESSAGES_HPP

namespace PyRiteMessages {

    // --- General Value & Operation Errors ---
    constexpr const char* ERROR_UNSUPPORTED_OPERAND_ADD = "Unsupported operand types for +.";
    constexpr const char* ERROR_UNSUPPORTED_OPERAND_SUB = "Unsupported operand types for -.";
    constexpr const char* ERROR_UNSUPPORTED_OPERAND_MUL = "Unsupported operand types for *.";
    constexpr const char* ERROR_UNSUPPORTED_OPERAND_DIV = "Unsupported operand types for /.";
    constexpr const char* ERROR_UNSUPPORTED_OPERAND_POW = "Unsupported operand types for ^.";
    constexpr const char* ERROR_UNSUPPORTED_COMPARISON = "Unsupported operand types for comparison.";
    constexpr const char* ERROR_OBJECT_NOT_SUBSCRIPTABLE = "Object is not subscriptable.";
    constexpr const char* ERROR_OBJECT_ITEM_ASSIGNMENT_UNSUPPORTED = "Object does not support item assignment.";
    constexpr const char* ERROR_LIST_REPEAT_COUNT_INTEGER = "List repetition count must be an integer.";
    constexpr const char* ERROR_LIST_INDEX_MUST_BE_NUMBER = "List index must be a number.";
    constexpr const char* ERROR_LIST_INDEX_OUT_OF_RANGE = "List index out of range.";
    constexpr const char* ERROR_INVALID_LIST_INDEX = "Invalid list index.";
    constexpr const char* ERROR_HEX_STRING_PREFIX = "Hex string must start with '0x'.";

    // --- Runtime & Interpreter Errors ---
    constexpr const char* RUNTIME_ERROR_PREFIX = "[Runtime Error] Line ";
    constexpr const char* RUNTIME_ERROR_UNDEFINED_VARIABLE_PREFIX = "Undefined variable '";
    constexpr const char* RUNTIME_ERROR_UNDEFINED_VARIABLE_SUFFIX = "'.";
    constexpr const char* RUNTIME_ERROR_UNCAUGHT_EXCEPTION_PREFIX = "[Uncaught Exception] ";
    constexpr const char* RUNTIME_ERROR_STACK_TRACE_HEADER = "Stack trace:";
    constexpr const char* RUNTIME_ERROR_STACK_TRACE_ENTRY_PREFIX = "  in ";
    constexpr const char* RUNTIME_ERROR_STACK_TRACE_ENTRY_SUFFIX = " (line ";
    constexpr const char* RUNTIME_ERROR_EXECUTION_TIMEOUT_PREFIX = "Execution timed out (";
    constexpr const char* RUNTIME_ERROR_EXECUTION_TIMEOUT_SUFFIX = "ms).";
    constexpr const char* RUNTIME_ERROR_INVALID_ASSIGNMENT_TARGET = "Invalid assignment target.";
    constexpr const char* RUNTIME_ERROR_CANNOT_CONVERT_STRING_TO_NUMBER_PREFIX = "Cannot convert string '";
    constexpr const char* RUNTIME_ERROR_CANNOT_CONVERT_STRING_TO_NUMBER_SUFFIX = "' to a number.";
    constexpr const char* RUNTIME_ERROR_CANNOT_CONVERT_STRING_TO_BINARY_PREFIX = "Cannot convert string '";
    constexpr const char* RUNTIME_ERROR_CANNOT_CONVERT_STRING_TO_BINARY_SUFFIX = "' to a binary object. Must be in '0x...' format.";
    constexpr const char* RUNTIME_ERROR_LIST_INIT_WITH_LIST_ONLY = "Can only initialize a list variable with a list.";
    constexpr const char* RUNTIME_ERROR_SET_NODE_HANDLED_BY_ASSIGNMENT = "SetNode should be handled via AssignmentNode.";
    constexpr const char* RUNTIME_ERROR_ONLY_INSTANCES_HAVE_PROPERTIES_PREFIX = "Only instances can have properties. Cannot get '";
    constexpr const char* RUNTIME_ERROR_ONLY_INSTANCES_HAVE_PROPERTIES_SUFFIX = "'.";
    constexpr const char* RUNTIME_ERROR_ONLY_INSTANCES_CAN_SET_PROPERTIES = "Only instances can set properties.";
    constexpr const char* RUNTIME_ERROR_UNDEFINED_PROPERTY_PREFIX = "Undefined property '";
    constexpr const char* RUNTIME_ERROR_UNDEFINED_PROPERTY_SUFFIX = "'.";
    constexpr const char* RUNTIME_ERROR_UNDEFINED_FIELD_PREFIX = "Cannot set undefined field '";
    constexpr const char* RUNTIME_ERROR_UNDEFINED_FIELD_SUFFIX = "'.";
    constexpr const char* RUNTIME_ERROR_FIELD_TYPE_MISMATCH_PREFIX = "Type mismatch for field '";
    constexpr const char* RUNTIME_ERROR_FIELD_TYPE_MISMATCH_EXPECTED = "'. Expected type '";
    constexpr const char* RUNTIME_ERROR_FIELD_TYPE_MISMATCH_GOT = "', but got '";
    constexpr const char* RUNTIME_ERROR_FIELD_TYPE_MISMATCH_SUFFIX = "'.";
    constexpr const char* RUNTIME_ERROR_CAN_ONLY_CALL_FUNCTIONS = "Can only call functions or methods. Callee was '";
    constexpr const char* RUNTIME_ERROR_CAN_ONLY_CALL_FUNCTIONS_SUFFIX = "'.";

    // --- Function & Method Call Errors ---
    constexpr const char* ERROR_ARG_COUNT_PREFIX_AT_LEAST = "' requires at least ";
    constexpr const char* ERROR_ARG_COUNT_PREFIX_EXACTLY = "' requires exactly ";
    constexpr const char* ERROR_ARG_COUNT_PREFIX_AT_MOST = "' takes at most ";
    constexpr const char* ERROR_ARG_COUNT_SUFFIX_BUT_GOT = " arguments, but received ";
    constexpr const char* ERROR_ARG_COUNT_SUFFIX_BUT_GOT_PLURAL = " argument(s), but received ";
    constexpr const char* ERROR_ARG_COUNT_SUFFIX_SINGLE = " argument.";
    constexpr const char* ERROR_ARG_COUNT_SUFFIX_PLURAL = " arguments.";
    constexpr const char* ERROR_ARG_TYPE_MISMATCH_PREFIX = "Type mismatch for argument ";
    constexpr const char* ERROR_ARG_TYPE_MISMATCH_IN_FUNCTION = " in function '";
    constexpr const char* ERROR_ARG_TYPE_MISMATCH_IN_METHOD = " in method '";
    constexpr const char* ERROR_ARG_TYPE_MISMATCH_NAME = " ('";
    constexpr const char* ERROR_ARG_TYPE_MISMATCH_EXPECTED = "'). Expected '";
    constexpr const char* ERROR_ARG_TYPE_MISMATCH_GOT = "', but got '";
    constexpr const char* ERROR_ARG_TYPE_MISMATCH_SUFFIX = "'.";
    constexpr const char* ERROR_SWAP_REQUIRES_TWO_VARS = "swap() requires 2 variable names as arguments.";
    constexpr const char* ERROR_SWAP_ARGS_MUST_BE_VARS = "swap() arguments must be variable names.";
    constexpr const char* ERROR_NEW_REQUIRES_CLASS = "The first argument to new() must be a class.";


    // --- Native Function Errors ---
    constexpr const char* NATIVE_ERROR_REQUIRES_ARGS_SUFFIX = "() requires ";
    constexpr const char* NATIVE_ERROR_REQUIRES_MIN_ARGS_SUFFIX = "() requires at least ";
    constexpr const char* NATIVE_ERROR_ARG_MUST_BE_NUMBER = "Argument must be a number.";
    constexpr const char* NATIVE_ERROR_ARG_MUST_BE_LIST = "Argument must be a list.";
    constexpr const char* NATIVE_ERROR_ARG_MUST_BE_STRING = "Argument must be a string.";
    constexpr const char* NATIVE_ERROR_RT_ARGS = "rt() requires 1 or 2 arguments.";
    constexpr const char* NATIVE_ERROR_MIN_MAX_EMPTY = "min/max requires at least one argument.";
    constexpr const char* NATIVE_ERROR_MIN_MAX_EMPTY_LIST = "Cannot find min/max of an empty list/argument set.";
    constexpr const char* NATIVE_ERROR_MIN_MAX_UNCOMPARABLE = "All arguments to min/max must be of a comparable type (number or string).";
    constexpr const char* NATIVE_ERROR_TIMER_FN_NO_ARGS = "Timer function does not accept arguments.";
    constexpr const char* NATIVE_ERROR_LOG_POSITIVE = "Argument to log() must be positive.";


    // --- Parser Errors ---
    constexpr const char* PARSE_ERROR_PREFIX = "[Parse Error] Line ";
    constexpr const char* PARSE_ERROR_SUFFIX = ".\n";
    constexpr const char* PARSE_ERROR_UNEXPECTED_CHAR = "Unexpected character.";
    constexpr const char* PARSE_ERROR_UNTERMINATED_STRING = "Unterminated string.";
    constexpr const char* PARSE_ERROR_EXPECT_EXPRESSION = "Expected expression.";
    constexpr const char* PARSE_ERROR_EXPECT_VAR_NAME = "Expected variable name.";
    constexpr const char* PARSE_ERROR_EXPECT_PARAM_TYPE = "Expected type keyword (dec, str, bin, list, any) for function parameter.";
    constexpr const char* PARSE_ERROR_EXPECT_PARAM_NAME = "Expected parameter name.";
    constexpr const char* PARSE_ERROR_DEFAULT_VALUE_LITERAL = "Default parameter value must be a literal (null, number, string, hex, empty list).";
    constexpr const char* PARSE_ERROR_UNSUPPORTED_DEFAULT_LIST = "Non-empty lists are not currently supported as default parameter values.";
    constexpr const char* PARSE_ERROR_TOO_MANY_PARAMS = "Cannot have more than 255 parameters.";
    constexpr const char* PARSE_ERROR_TOO_MANY_FIELDS = "Cannot have more than 255 class fields.";
    constexpr const char* PARSE_ERROR_TOO_MANY_ARGS = "Cannot have more than 255 arguments.";
    constexpr const char* PARSE_ERROR_EXPECT_FUNC_NAME = "Expected function name.";
    constexpr const char* PARSE_ERROR_EXPECT_METHOD_NAME = "Expected method name.";
    constexpr const char* PARSE_ERROR_EXPECT_LPAREN_AFTER_NAME = "' after name.";
    constexpr const char* PARSE_ERROR_EXPECT_RPAREN_AFTER_PARAMS = "')' after parameters.";
    constexpr const char* PARSE_ERROR_EXPECT_DO_BEFORE_BODY = "'do' before function body.";
    constexpr const char* PARSE_ERROR_EXPECT_ENDDEF_AFTER_BODY = "'enddef' after function body.";
    constexpr const char* PARSE_ERROR_EXPECT_CLASS_NAME = "Expected class name.";
    constexpr const char* PARSE_ERROR_EXPECT_RPAREN_AFTER_FIELDS = "')' after fields.";
    constexpr const char* PARSE_ERROR_EXPECT_CONTAINS_AFTER_CLASS_DEF = "'contains' after class definition.";
    constexpr const char* PARSE_ERROR_EXPECT_ENDINS_AFTER_CLASS_BODY = "'endins' after class body.";
    constexpr const char* PARSE_ERROR_ONLY_METHODS_IN_CLASS = "Only method definitions (def) are allowed inside a class 'contains' block.";
    constexpr const char* PARSE_ERROR_EXPECT_THEN_AFTER_IF = "'then' after if condition.";
    constexpr const char* PARSE_ERROR_EXPECT_ENDIF_AFTER_IF = "'endif' after if statement.";
    constexpr const char* PARSE_ERROR_EXPECT_DO_AFTER_WHILE = "'do' after while condition.";
    constexpr const char* PARSE_ERROR_EXPECT_ENDWHILE_AFTER_WHILE = "'endwhile' after while loop.";
    constexpr const char* PARSE_ERROR_EXPECT_THEN_AFTER_AWAIT = "'then' after await condition.";
    constexpr const char* PARSE_ERROR_EXPECT_ENDAWAIT_AFTER_AWAIT = "'endawait' after await statement.";
    constexpr const char* PARSE_ERROR_EXPECT_CATCH_AFTER_TRY = "'catch' after 'try' block.";
    constexpr const char* PARSE_ERROR_EXPECT_VAR_AFTER_CATCH = "Expected a variable name after 'catch'.";
    constexpr const char* PARSE_ERROR_EXPECT_ENDTRY_AFTER_TRY = "'endtry' after try/catch/finally structure.";
    constexpr const char* PARSE_ERROR_EXPECT_LPAREN_AFTER_SAY = "'say' requires '('.";
    constexpr const char* PARSE_ERROR_EXPECT_RPAREN_AFTER_EXPR = "')' after expression.";
    constexpr const char* PARSE_ERROR_EXPECT_LPAREN_AFTER_ASK = "'ask' requires '('.";
    constexpr const char* PARSE_ERROR_EXPECT_RPAREN_AFTER_PROMPT = "')' after prompt.";
    constexpr const char* PARSE_ERROR_EXPECT_RBRACKET_AFTER_LIST = "']' after list elements.";
    constexpr const char* PARSE_ERROR_EXPECT_RBRACKET_AFTER_INDEX = "']' after subscript index.";
    constexpr const char* PARSE_ERROR_EXPECT_PROP_NAME = "Expected property or method name.";


    // --- Debug Messages ---
    constexpr const char* DEBUG_ENV_DEFINE = "[Debug:Environment] Defining '";
    constexpr const char* DEBUG_ENV_IN_ENV = "' in environment ";
    constexpr const char* DEBUG_ENV_AS = " as ";
    constexpr const char* DEBUG_ENV_ASSIGN = "[Debug:Environment] Assigning to '";
    constexpr const char* DEBUG_ENV_VALUE = "' = ";
    constexpr const char* DEBUG_ENV_ASSIGN_FAIL = "[Debug:Environment] Assignment failed in ";
    constexpr const char* DEBUG_ENV_TRY_ENCLOSING = ", trying enclosing environment ";
    constexpr const char* DEBUG_ENV_GET = "[Debug:Environment] Getting '";
    constexpr const char* DEBUG_ENV_FROM_ENV = "' from environment ";
    constexpr const char* DEBUG_ENV_FOUND = "  Found '";
    constexpr const char* DEBUG_ENV_GET_FAIL = "  Get failed in ";
    constexpr const char* DEBUG_PARSER_START = "[Debug:Parser] Starting parse...";
    constexpr const char* DEBUG_PARSER_PARSING_DECL = "[Debug:Parser] Parsing declaration (current token: ";
    constexpr const char* DEBUG_PARSER_PARSING_PARAM = "[Debug:Parser] Parsing parameter...";
    constexpr const char* DEBUG_PARSER_PARSING_DEFAULT_VAL_FOR = "  Parsing default value for '";
    constexpr const char* DEBUG_PARSER_PARSED_PARAM = "  Parsed parameter: ";
    constexpr const char* DEBUG_PARSER_WITH_DEFAULT = " (with default)";
    constexpr const char* DEBUG_PARSER_PARSING_VAR_DECL = "[Debug:Parser] Parsing variable declaration...";
    constexpr const char* DEBUG_PARSER_PARSING_FUNC_DEF = "[Debug:Parser] Parsing function definition...";
    constexpr const char* DEBUG_PARSER_PARSING_METHOD_DEF = "[Debug:Parser] Parsing method definition...";
    constexpr const char* DEBUG_PARSER_DONE_PARSING_FUNC = "  Done parsing function '";
    constexpr const char* DEBUG_PARSER_DONE_PARSING_METHOD = "  Done parsing method '";
    constexpr const char* DEBUG_PARSER_PARSING_CLASS_DEF = "[Debug:Parser] Parsing class definition...";
    constexpr const char* DEBUG_PARSER_DONE_PARSING_CLASS = "  Done parsing class '";
    constexpr const char* DEBUG_PARSER_PARSING_ASSIGNMENT = "[Debug:Parser] Parsing assignment expression...";
    constexpr const char* DEBUG_PARSER_PARSING_CALL = "[Debug:Parser] Parsing function call...";
    constexpr const char* DEBUG_PARSER_PARSING_SUBSCRIPT = "[Debug:Parser] Parsing subscript access...";
    constexpr const char* DEBUG_PARSER_PARSING_GET = "[Debug:Parser] Parsing property/method access...";
    constexpr const char* DEBUG_INTERP_START = "[Debug:Interpreter] Starting interpretation of ";
    constexpr const char* DEBUG_INTERP_STATEMENTS = " statements.";
    constexpr const char* DEBUG_INTERP_EXEC_TOP_LEVEL = "[Debug:Interpreter] === Executing top-level statement ";
    constexpr const char* DEBUG_INTERP_AT_LINE = " (line ";
    constexpr const char* DEBUG_INTERP_END_EXEC_STMT = ") ===";
    constexpr const char* DEBUG_INTERP_DONE = "[Debug:Interpreter] Interpretation finished.";
    constexpr const char* DEBUG_INTERP_EXEC_STMT_TYPE = "[Debug:Interpreter] Executing statement of type ";
    constexpr const char* DEBUG_INTERP_EVAL_EXPR_TYPE = "[Debug:Interpreter] Evaluating expression of type ";
    constexpr const char* DEBUG_INTERP_BLOCK_ENTER = "[Debug:Interpreter] ---> Entering new block/scope. Env: ";
    constexpr const char* DEBUG_INTERP_BLOCK_PREVIOUS = " Previous: ";
    constexpr const char* DEBUG_INTERP_BLOCK_EXIT_EXCEPTION = "[Debug:Interpreter] <--- Exiting block/scope due to exception. Restoring env to ";
    constexpr const char* DEBUG_INTERP_BLOCK_EXIT = "[Debug:Interpreter] <--- Exiting block/scope. Restoring env to ";
    constexpr const char* DEBUG_EXEC_LITERAL_NODE = "[Debug:Exec] Evaluating LiteralNode. Value: ";
    constexpr const char* DEBUG_EXEC_LIST_LITERAL_NODE = "[Debug:Exec] Evaluating ListLiteralNode with ";
    constexpr const char* DEBUG_EXEC_LIST_LITERAL_NODE_ELEMENTS = " elements.";
    constexpr const char* DEBUG_EXEC_VAR_NODE = "[Debug:Exec] Evaluating VariableNode '";
    constexpr const char* DEBUG_EXEC_ASSIGN_NODE = "[Debug:Exec] Executing AssignmentNode. Value to assign: ";
    constexpr const char* DEBUG_EXEC_ASSIGN_TARGET_VAR = "  Assignment target is VariableNode: '";
    constexpr const char* DEBUG_EXEC_ASSIGN_TARGET_SUBSCRIPT = "  Assignment target is SubscriptNode.";
    constexpr const char* DEBUG_EXEC_ASSIGN_TARGET_GET = "  Assignment target is GetNode: property '";
    constexpr const char* DEBUG_EXEC_VAR_DECL_NODE_INIT = "[Debug:Exec] Executing VarDeclarationNode for '";
    constexpr const char* DEBUG_EXEC_VAR_DECL_NODE_WITH_INIT = "' with initializer.";
    constexpr const char* DEBUG_EXEC_VAR_DECL_NODE_NO_INIT = "' without initializer.";
    constexpr const char* DEBUG_EXEC_VAR_DECL_DECLARED_TYPE = "  Declared type: ";
    constexpr const char* DEBUG_EXEC_VAR_DECL_INITIAL_VALUE = ". Initial value: ";
    constexpr const char* DEBUG_EXEC_VAR_DECL_FINAL_VALUE = "  Final value after coercion: ";
    constexpr const char* DEBUG_EXEC_BINARY_OP = "[Debug:Exec] Evaluating BinaryOpNode (operator: ";
    constexpr const char* DEBUG_EXEC_BINARY_OP_LEFT = "  Left operand: ";
    constexpr const char* DEBUG_EXEC_BINARY_OP_RIGHT = ", Right operand: ";
    constexpr const char* DEBUG_EXEC_SUBSCRIPT_NODE = "[Debug:Exec] Evaluating SubscriptNode.";
    constexpr const char* DEBUG_EXEC_SUBSCRIPT_NODE_OBJ = "  Object: ";
    constexpr const char* DEBUG_EXEC_SUBSCRIPT_NODE_IDX = ", Index: ";
    constexpr const char* DEBUG_EXEC_IF_NODE = "[Debug:Exec] Executing IfStatementNode. Evaluating condition...";
    constexpr const char* DEBUG_EXEC_IF_CONDITION_TRUE = "  Condition is true";
    constexpr const char* DEBUG_EXEC_IF_CONDITION_FALSE = "  Condition is false";
    constexpr const char* DEBUG_EXEC_IF_CONDITION_VALUE = " (";
    constexpr const char* DEBUG_EXEC_IF_THEN = "  Executing 'then' branch.";
    constexpr const char* DEBUG_EXEC_IF_ELSE = "  Executing 'else' branch.";
    constexpr const char* DEBUG_EXEC_WHILE_NODE = "[Debug:Exec] Executing WhileStatementNode.";
    constexpr const char* DEBUG_EXEC_WHILE_CONDITION_TRUE = "  While loop condition is true";
    constexpr const char* DEBUG_EXEC_WHILE_CONDITION_FALSE = "  While loop condition is false";
    constexpr const char* DEBUG_EXEC_WHILE_FINALLY = "  Executing while loop's 'finally' branch.";
    constexpr const char* DEBUG_EXEC_AWAIT_NODE = "[Debug:Exec] Executing AwaitStatementNode. Waiting for condition...";
    constexpr const char* DEBUG_EXEC_AWAIT_SATISFIED = "  Await condition satisfied. Executing 'then' branch.";
    constexpr const char* DEBUG_EXEC_SAY_NODE = "[Debug:Exec] Executing SayNode.";
    constexpr const char* DEBUG_EXEC_SAY_VALUE = "  Value to say: ";
    constexpr const char* DEBUG_EXEC_FUNC_DEF_NODE = "[Debug:Exec] Executing FunctionDefNode for '";
    constexpr const char* DEBUG_EXEC_CLASS_DEF_NODE = "[Debug:Exec] Executing ClassDefNode for class '";
    constexpr const char* DEBUG_EXEC_CLASS_DEF_PROCESSING_METHOD = "  Processing method '";
    constexpr const char* DEBUG_EXEC_GET_NODE = "[Debug:Exec] Evaluating GetNode for property '";
    constexpr const char* DEBUG_EXEC_GET_NODE_OBJECT_EVAL = "  Object evaluated to: ";
    constexpr const char* DEBUG_EXEC_CALL_NODE = "[Debug:Exec] Executing CallNode (line ";
    constexpr const char* DEBUG_EXEC_CALL_NODE_EVAL_CALLEE = "). Evaluating callee...";
    constexpr const char* DEBUG_EXEC_CALL_NODE_CALLEE_EVAL = "  Callee evaluated to: ";
    constexpr const char* DEBUG_EXEC_CALL_NODE_EVAL_ARGS = "  Evaluating ";
    constexpr const char* DEBUG_EXEC_CALL_NODE_ARGS = " arguments...";
    constexpr const char* DEBUG_EXEC_CALL_NODE_NATIVE = "  Calling native function '";
    constexpr const char* DEBUG_EXEC_CALL_NODE_USER = "  Calling user function '";
    constexpr const char* DEBUG_EXEC_CALL_NODE_BINDING_ARGS = "    Binding ";
    constexpr const char* DEBUG_EXEC_CALL_NODE_ARGS_TO = " args to ";
    constexpr const char* DEBUG_EXEC_CALL_NODE_PARAMS = " params (";
    constexpr const char* DEBUG_EXEC_CALL_NODE_REQUIRED = " required).";
    constexpr const char* DEBUG_EXEC_CALL_NODE_BINDING_PARAM = "      Binding param '";
    constexpr const char* DEBUG_EXEC_CALL_NODE_TO_ARG = "' to argument ";
    constexpr const char* DEBUG_EXEC_CALL_NODE_PUSH_STACK = "    Pushing '";
    constexpr const char* DEBUG_EXEC_CALL_NODE_TO_STACK = "' to call stack.";
    constexpr const char* DEBUG_EXEC_CALL_NODE_POP_STACK = "    Popping '";
    constexpr const char* DEBUG_EXEC_CALL_NODE_FROM_STACK = "' from call stack. Return value: ";
    constexpr const char* DEBUG_EXEC_CALL_NODE_BOUND_METHOD = "  Calling bound method '";
    constexpr const char* DEBUG_EXEC_CALL_NODE_ON_INSTANCE = "' on instance ";
    constexpr const char* DEBUG_EXEC_CALL_NODE_DEFINE_THIS = "    Defining 'this' in method scope.";
    constexpr const char* DEBUG_EXEC_RETURN_NODE = "[Debug:Exec] Executing ReturnNode. Throwing ReturnValueException with value ";
    constexpr const char* DEBUG_EXEC_RAISE_NODE = "[Debug:Exec] Executing RaiseNode. Throwing PyRiteRaiseException with payload ";
    constexpr const char* DEBUG_EXEC_TRY_NODE = "[Debug:Exec] Executing TryCatchNode. Entering 'try' block.";
    constexpr const char* DEBUG_EXEC_TRY_CAUGHT_PYRITE = "  Caught PyRiteRaiseException in 'try' block. Payload: ";
    constexpr const char* DEBUG_EXEC_TRY_EXEC_CATCH = ". Executing 'catch' block.";
    constexpr const char* DEBUG_EXEC_TRY_CAUGHT_RUNTIME = "  Caught RuntimeError in 'try' block: ";
    constexpr const char* DEBUG_EXEC_TRY_CAUGHT_UNEXPECTED = "  Caught unexpected exception in 'catch' block. It will be re-thrown after 'finally'.";
    constexpr const char* DEBUG_EXEC_TRY_EXEC_FINALLY = "  Executing 'finally' block.";
    constexpr const char* DEBUG_EXEC_TRY_RETHROWING = "  Rethrowing exception from 'catch' block.";
    constexpr const char* DEBUG_EXEC_TRY_DONE = "  TryCatchNode execution finished.";
    constexpr const char* DEBUG_EXEC_EXPR_STMT_NODE = "[Debug:Exec] Executing ExpressionStatementNode.";
    constexpr const char* DEBUG_INSTANCE_CREATING = "[Debug:Instance] Creating instance of '";
    constexpr const char* DEBUG_INSTANCE_NEW_ENV = "'. Creating new environment, enclosed by ";
    constexpr const char* DEBUG_INSTANCE_INIT_FIELD = "  Initializing field '";
    constexpr const char* DEBUG_INSTANCE_WITH_DEFAULT = "' with default value ";
    constexpr const char* DEBUG_INSTANCE_GET_PROP = "[Debug:Instance] Getting property '";
    constexpr const char* DEBUG_INSTANCE_FROM = "' from instance of '";
    constexpr const char* DEBUG_INSTANCE_CHECK_FIELDS = "  Checking instance fields...";
    constexpr const char* DEBUG_INSTANCE_PROP_NOT_IN_FIELDS = "  Property '";
    constexpr const char* DEBUG_INSTANCE_CHECK_METHODS = "' not in fields. Checking class methods...";
    constexpr const char* DEBUG_INSTANCE_FOUND_METHOD = "  Found method '";
    constexpr const char* DEBUG_INSTANCE_CREATING_BOUND_METHOD = "'. Creating bound method.";
    constexpr const char* DEBUG_INSTANCE_SET_PROP = "[Debug:Instance] Setting property '";
    constexpr const char* DEBUG_INSTANCE_FOR = "' for instance of '";
    constexpr const char* DEBUG_INSTANCE_TO_VALUE = "' to value ";
    constexpr const char* DEBUG_INSTANCE_FOUND_FIELD = "  Found field '";
    constexpr const char* DEBUG_INSTANCE_TYPE_CHECKING = "'. Type checking... Expected: ";
    constexpr const char* DEBUG_INSTANCE_TYPE_CHECK_OK = "  Type check passed. Setting field value.";

    // --- REPL & Main ---
    constexpr const char* REPL_WELCOME_BANNER_1 = "PyRite Interpreter 0.19.0 (tags/v0.19.0, compilers/TDM-GCC 4.9.2 64-bit Release)";
    constexpr const char* REPL_WELCOME_BANNER_DEBUG = " [DEBUG]";
    constexpr const char* REPL_WELCOME_BANNER_2 = ".\n";
    constexpr const char* REPL_WELCOME_BANNER_3 = "Enter 'run()' to execute buffered code, 'compile()' to compile, 'halt()' to exit, 'about()' for version info.\n";
    constexpr const char* REPL_HALTED = "Interpreter halted.";
    constexpr const char* REPL_NO_CODE_TO_RUN = "No code to execute.";
    constexpr const char* REPL_TICK_ARG_ERROR = "[Runtime Error] run() 'tick' argument must be a boolean (0/1, false/true).";
    constexpr const char* REPL_LIMIT_ARG_ERROR_LITERAL = "[Runtime Error] run() 'limit' argument must be a number literal.";
    constexpr const char* REPL_LIMIT_ARG_ERROR_INVALID = "[Runtime Error] Invalid 'limit' argument for run().";
    constexpr const char* REPL_EXECUTION_TIME_PREFIX = "Code execution time: ";
    constexpr const char* REPL_EXECUTION_TIME_SUFFIX = "ms.";
    constexpr const char* ABOUT_HEADER_FOOTER = "----------------------------------------\n";
    constexpr const char* ABOUT_LINE_1 = " PyRite Language Interpreter v0.19.0";
    constexpr const char* ABOUT_LINE_2 = "\n (c) 2024-2025. DarkstarXD. All Rights Reserved.\n";
    constexpr const char* ABOUT_LINE_3 = " A programming language that's simple to the point of being magical?!\n";
    constexpr const char* MAIN_USAGE_ERROR = "Usage: ";
    constexpr const char* MAIN_USAGE_ERROR_SCRIPT = " [script.src]";
    constexpr const char* MAIN_FILE_OPEN_ERROR = "Error: Could not open file '";

    // --- Compilation ---
    constexpr const char* COMPILE_SYNTAX_ERROR = "Syntax Error: Call is missing '()'.";
    constexpr const char* COMPILE_ARG_SYNTAX_ERROR = "Syntax Error: Arguments must be in key=value format.";
    constexpr const char* COMPILE_ERROR_PREFIX = "[Compile Error] ";
    constexpr const char* COMPILE_ERROR_SUFFIX = ".";
    constexpr const char* COMPILE_BUFFER_EMPTY = "Buffer is empty, cannot compile.";
    constexpr const char* COMPILE_CANNOT_OPEN_SOURCE = "Cannot open source file: ";
    constexpr const char* COMPILE_CANNOT_OPEN_TEMPLATE = "Cannot open compiler template file: ";
    constexpr const char* COMPILE_TEMPLATE_PLACEHOLDER_MISSING = "Placeholder WRITE_SRC_CODE_HERE not found in template.cpp.";
    constexpr const char* COMPILE_TRANSLATION_TARGET = "Translation target: ";
    constexpr const char* COMPILE_CANNOT_OPEN_TEMP_WRITE = "Cannot open temporary compile file for writing (check permissions and path): ";
    constexpr const char* COMPILE_WRITE_TEMP_FAILED = "Failed to write to temporary compile file (could be a permissions issue or disk full): ";
    constexpr const char* COMPILE_COMMAND_INFO = "Using compile command: ";
    constexpr const char* COMPILE_SUCCESS_PREFIX = "Successfully compiled ";
    constexpr const char* COMPILE_SUCCESS_TOOK = " (took ";
    constexpr const char* COMPILE_SUCCESS_SECONDS = " s) output to ";
    constexpr const char* COMPILE_FAILURE_PREFIX = "Compilation of ";
    constexpr const char* COMPILE_FAILURE_SUFFIX = " failed (compiler error)";
}

#endif // MESSAGES_HPP
