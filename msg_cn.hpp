#ifndef MESSAGES_HPP
#define MESSAGES_HPP

namespace PyRiteMessages {

    // --- 通用值与操作错误 ---
    constexpr const char* ERROR_UNSUPPORTED_OPERAND_ADD = "不支持的 '+' 操作数类型。";
    constexpr const char* ERROR_UNSUPPORTED_OPERAND_SUB = "不支持的 '-' 操作数类型。";
    constexpr const char* ERROR_UNSUPPORTED_OPERAND_MUL = "不支持的 '*' 操作数类型。";
    constexpr const char* ERROR_UNSUPPORTED_OPERAND_DIV = "不支持的 '/' 操作数类型。";
    constexpr const char* ERROR_UNSUPPORTED_OPERAND_POW = "不支持的 '^' 操作数类型。";
    constexpr const char* ERROR_UNSUPPORTED_COMPARISON = "不支持的比较操作数类型。";
    constexpr const char* ERROR_OBJECT_NOT_SUBSCRIPTABLE = "对象不可下标访问。";
    constexpr const char* ERROR_OBJECT_ITEM_ASSIGNMENT_UNSUPPORTED = "对象不支持元素赋值。";
    constexpr const char* ERROR_LIST_REPEAT_COUNT_INTEGER = "列表重复次数必须为整数。";
    constexpr const char* ERROR_LIST_INDEX_MUST_BE_NUMBER = "列表索引必须是数字。";
    constexpr const char* ERROR_LIST_INDEX_OUT_OF_RANGE = "列表索引超出范围。";
    constexpr const char* ERROR_INVALID_LIST_INDEX = "无效的列表索引。";
    constexpr const char* ERROR_HEX_STRING_PREFIX = "十六进制字符串必须以 '0x' 开头。";

    // --- 运行时与解释器错误 ---
    constexpr const char* RUNTIME_ERROR_PREFIX = "[运行时错误] 第 ";
    constexpr const char* RUNTIME_ERROR_UNDEFINED_VARIABLE_PREFIX = "未定义的变量 '";
    constexpr const char* RUNTIME_ERROR_UNDEFINED_VARIABLE_SUFFIX = "'。";
    constexpr const char* RUNTIME_ERROR_UNCAUGHT_EXCEPTION_PREFIX = "[未捕获的异常] ";
    constexpr const char* RUNTIME_ERROR_STACK_TRACE_HEADER = "堆栈跟踪:";
    constexpr const char* RUNTIME_ERROR_STACK_TRACE_ENTRY_PREFIX = "  在 ";
    constexpr const char* RUNTIME_ERROR_STACK_TRACE_ENTRY_SUFFIX = " (第 ";
    constexpr const char* RUNTIME_ERROR_EXECUTION_TIMEOUT_PREFIX = "执行超时 (";
    constexpr const char* RUNTIME_ERROR_EXECUTION_TIMEOUT_SUFFIX = "毫秒)。";
    constexpr const char* RUNTIME_ERROR_INVALID_ASSIGNMENT_TARGET = "无效的赋值目标。";
    constexpr const char* RUNTIME_ERROR_CANNOT_CONVERT_STRING_TO_NUMBER_PREFIX = "无法将字符串 '";
    constexpr const char* RUNTIME_ERROR_CANNOT_CONVERT_STRING_TO_NUMBER_SUFFIX = "' 转换为数字。";
    constexpr const char* RUNTIME_ERROR_CANNOT_CONVERT_STRING_TO_BINARY_PREFIX = "无法将字符串 '";
    constexpr const char* RUNTIME_ERROR_CANNOT_CONVERT_STRING_TO_BINARY_SUFFIX = "' 转换为二进制对象。必须为 '0x...' 格式。";
    constexpr const char* RUNTIME_ERROR_LIST_INIT_WITH_LIST_ONLY = "只能用列表初始化列表变量。";
    constexpr const char* RUNTIME_ERROR_SET_NODE_HANDLED_BY_ASSIGNMENT = "SetNode 应通过 AssignmentNode 处理。";
    constexpr const char* RUNTIME_ERROR_ONLY_INSTANCES_HAVE_PROPERTIES_PREFIX = "只有实例才能拥有属性。无法获取 '";
    constexpr const char* RUNTIME_ERROR_ONLY_INSTANCES_HAVE_PROPERTIES_SUFFIX = "'。";
    constexpr const char* RUNTIME_ERROR_ONLY_INSTANCES_CAN_SET_PROPERTIES = "只有实例才能设置属性。";
    constexpr const char* RUNTIME_ERROR_UNDEFINED_PROPERTY_PREFIX = "未定义的属性 '";
    constexpr const char* RUNTIME_ERROR_UNDEFINED_PROPERTY_SUFFIX = "'。";
    constexpr const char* RUNTIME_ERROR_UNDEFINED_FIELD_PREFIX = "无法设置未定义的字段 '";
    constexpr const char* RUNTIME_ERROR_UNDEFINED_FIELD_SUFFIX = "'。";
    constexpr const char* RUNTIME_ERROR_FIELD_TYPE_MISMATCH_PREFIX = "字段 '";
    constexpr const char* RUNTIME_ERROR_FIELD_TYPE_MISMATCH_EXPECTED = "' 类型不匹配。期望类型 '";
    constexpr const char* RUNTIME_ERROR_FIELD_TYPE_MISMATCH_GOT = "', 但得到 '";
    constexpr const char* RUNTIME_ERROR_FIELD_TYPE_MISMATCH_SUFFIX = "'。";
    constexpr const char* RUNTIME_ERROR_CAN_ONLY_CALL_FUNCTIONS = "只能调用函数或方法。被调用者是 '";
    constexpr const char* RUNTIME_ERROR_CAN_ONLY_CALL_FUNCTIONS_SUFFIX = "'。";

    // --- 函数与方法调用错误 ---
    constexpr const char* ERROR_ARG_COUNT_PREFIX_AT_LEAST = "' 至少需要 ";
    constexpr const char* ERROR_ARG_COUNT_PREFIX_EXACTLY = "' 需要 ";
    constexpr const char* ERROR_ARG_COUNT_PREFIX_AT_MOST = "' 最多接受 ";
    constexpr const char* ERROR_ARG_COUNT_SUFFIX_BUT_GOT = " 个参数, 但收到了 ";
    constexpr const char* ERROR_ARG_COUNT_SUFFIX_BUT_GOT_PLURAL = " 个参数, 但收到了 ";
    constexpr const char* ERROR_ARG_COUNT_SUFFIX_SINGLE = " 个参数。";
    constexpr const char* ERROR_ARG_COUNT_SUFFIX_PLURAL = " 个参数。";
    constexpr const char* ERROR_ARG_TYPE_MISMATCH_PREFIX = "参数 ";
    constexpr const char* ERROR_ARG_TYPE_MISMATCH_IN_FUNCTION = " (在函数 '";
    constexpr const char* ERROR_ARG_TYPE_MISMATCH_IN_METHOD = " (在方法 '";
    constexpr const char* ERROR_ARG_TYPE_MISMATCH_NAME = " ('";
    constexpr const char* ERROR_ARG_TYPE_MISMATCH_EXPECTED = "') 类型不匹配。期望 '";
    constexpr const char* ERROR_ARG_TYPE_MISMATCH_GOT = "', 但得到 '";
    constexpr const char* ERROR_ARG_TYPE_MISMATCH_SUFFIX = "'。";
    constexpr const char* ERROR_SWAP_REQUIRES_TWO_VARS = "swap() 需要 2 个变量名作为参数。";
    constexpr const char* ERROR_SWAP_ARGS_MUST_BE_VARS = "swap() 的参数必须是变量名。";
    constexpr const char* ERROR_NEW_REQUIRES_CLASS = "new() 的第一个参数必须是类。";


    // --- 原生函数错误 ---
    constexpr const char* NATIVE_ERROR_REQUIRES_ARGS_SUFFIX = "() 需要 ";
    constexpr const char* NATIVE_ERROR_REQUIRES_MIN_ARGS_SUFFIX = "() 至少需要 ";
    constexpr const char* NATIVE_ERROR_ARG_MUST_BE_NUMBER = "参数必须是数字。";
    constexpr const char* NATIVE_ERROR_ARG_MUST_BE_LIST = "参数必须是列表。";
    constexpr const char* NATIVE_ERROR_ARG_MUST_BE_STRING = "参数必须是字符串。";
    constexpr const char* NATIVE_ERROR_RT_ARGS = "rt() 需要 1 或 2 个参数。";
    constexpr const char* NATIVE_ERROR_MIN_MAX_EMPTY = "min/max 至少需要一个参数。";
    constexpr const char* NATIVE_ERROR_MIN_MAX_EMPTY_LIST = "无法在空列表/参数集中找到 min/max。";
    constexpr const char* NATIVE_ERROR_MIN_MAX_UNCOMPARABLE = "min/max 的所有参数必须是可比较的类型 (数字或字符串)。";
    constexpr const char* NATIVE_ERROR_TIMER_FN_NO_ARGS = "计时器函数不接受参数。";
    constexpr const char* NATIVE_ERROR_LOG_POSITIVE = "log() 的参数必须是正数。";


    // --- 解析器错误 ---
    constexpr const char* PARSE_ERROR_PREFIX = "[解析错误] 第 ";
    constexpr const char* PARSE_ERROR_SUFFIX = "行。\n";
    constexpr const char* PARSE_ERROR_UNEXPECTED_CHAR = "意外的字符。";
    constexpr const char* PARSE_ERROR_UNTERMINATED_STRING = "未终止的字符串。";
    constexpr const char* PARSE_ERROR_EXPECT_EXPRESSION = "缺少表达式。";
    constexpr const char* PARSE_ERROR_EXPECT_VAR_NAME = "缺少变量名。";
    constexpr const char* PARSE_ERROR_EXPECT_PARAM_TYPE = "函数参数缺少类型关键字 (dec, str, bin, list, any)。";
    constexpr const char* PARSE_ERROR_EXPECT_PARAM_NAME = "缺少参数名。";
    constexpr const char* PARSE_ERROR_DEFAULT_VALUE_LITERAL = "默认参数值必须是字面量 (null, 数字, 字符串, 十六进制, 空列表)。";
    constexpr const char* PARSE_ERROR_UNSUPPORTED_DEFAULT_LIST = "当前不支持非空列表作为默认参数值。";
    constexpr const char* PARSE_ERROR_TOO_MANY_PARAMS = "参数不能超过 255 个。";
    constexpr const char* PARSE_ERROR_TOO_MANY_FIELDS = "类字段不能超过 255 个。";
    constexpr const char* PARSE_ERROR_TOO_MANY_ARGS = "参数不能超过 255 个。";
    constexpr const char* PARSE_ERROR_EXPECT_FUNC_NAME = "缺少函数名。";
    constexpr const char* PARSE_ERROR_EXPECT_METHOD_NAME = "缺少方法名。";
    constexpr const char* PARSE_ERROR_EXPECT_LPAREN_AFTER_NAME = "名称后缺少 '('。";
    constexpr const char* PARSE_ERROR_EXPECT_RPAREN_AFTER_PARAMS = "参数后缺少 ')'。";
    constexpr const char* PARSE_ERROR_EXPECT_DO_BEFORE_BODY = "函数体前缺少 'do'。";
    constexpr const char* PARSE_ERROR_EXPECT_ENDDEF_AFTER_BODY = "函数体后缺少 'enddef'。";
    constexpr const char* PARSE_ERROR_EXPECT_CLASS_NAME = "缺少类名。";
    constexpr const char* PARSE_ERROR_EXPECT_RPAREN_AFTER_FIELDS = "字段后缺少 ')'。";
    constexpr const char* PARSE_ERROR_EXPECT_CONTAINS_AFTER_CLASS_DEF = "类定义后缺少 'contains'。";
    constexpr const char* PARSE_ERROR_EXPECT_ENDINS_AFTER_CLASS_BODY = "类体后缺少 'endins'。";
    constexpr const char* PARSE_ERROR_ONLY_METHODS_IN_CLASS = "类的 'contains' 块内只允许方法定义 (def)。";
    constexpr const char* PARSE_ERROR_EXPECT_THEN_AFTER_IF = "if 条件后缺少 'then'。";
    constexpr const char* PARSE_ERROR_EXPECT_ENDIF_AFTER_IF = "if 语句后缺少 'endif'。";
    constexpr const char* PARSE_ERROR_EXPECT_DO_AFTER_WHILE = "while 条件后缺少 'do'。";
    constexpr const char* PARSE_ERROR_EXPECT_ENDWHILE_AFTER_WHILE = "while 循环后缺少 'endwhile'。";
    constexpr const char* PARSE_ERROR_EXPECT_THEN_AFTER_AWAIT = "await 条件后缺少 'then'。";
    constexpr const char* PARSE_ERROR_EXPECT_ENDAWAIT_AFTER_AWAIT = "await 语句后缺少 'endawait'。";
    constexpr const char* PARSE_ERROR_EXPECT_CATCH_AFTER_TRY = "'try' 块后缺少 'catch'。";
    constexpr const char* PARSE_ERROR_EXPECT_VAR_AFTER_CATCH = "'catch' 后缺少变量名。";
    constexpr const char* PARSE_ERROR_EXPECT_ENDTRY_AFTER_TRY = "try/catch/finally 结构后缺少 'endtry'。";
    constexpr const char* PARSE_ERROR_EXPECT_LPAREN_AFTER_SAY = "'say' 需要 '('。";
    constexpr const char* PARSE_ERROR_EXPECT_RPAREN_AFTER_EXPR = "表达式后缺少 ')'。";
    constexpr const char* PARSE_ERROR_EXPECT_LPAREN_AFTER_ASK = "'ask' 需要 '('。";
    constexpr const char* PARSE_ERROR_EXPECT_RPAREN_AFTER_PROMPT = "提示符后缺少 ')'。";
    constexpr const char* PARSE_ERROR_EXPECT_RBRACKET_AFTER_LIST = "列表元素后缺少 ']'。";
    constexpr const char* PARSE_ERROR_EXPECT_RBRACKET_AFTER_INDEX = "下标索引后缺少 ']'。";
    constexpr const char* PARSE_ERROR_EXPECT_PROP_NAME = "缺少属性或方法名。";


    // --- 调试信息 ---
    constexpr const char* DEBUG_ENV_DEFINE = "[调试:环境] 定义 ";
    constexpr const char* DEBUG_ENV_IN_ENV = " 于环境 '";
    constexpr const char* DEBUG_ENV_AS = "' 为 ";
    constexpr const char* DEBUG_ENV_ASSIGN = "[调试:环境] 正在赋值给 '";
    constexpr const char* DEBUG_ENV_VALUE = "' = ";
    constexpr const char* DEBUG_ENV_ASSIGN_FAIL = "[调试:环境] 在 ";
    constexpr const char* DEBUG_ENV_TRY_ENCLOSING = " 中赋值失败, 尝试外层环境 ";
    constexpr const char* DEBUG_ENV_GET = "[调试:环境] 正在获取 '";
    constexpr const char* DEBUG_ENV_FROM_ENV = "' 从环境 ";
    constexpr const char* DEBUG_ENV_FOUND = "  找到 '";
    constexpr const char* DEBUG_ENV_GET_FAIL = "  在 ";
    constexpr const char* DEBUG_PARSER_START = "[调试:解析器] 开始解析...";
    constexpr const char* DEBUG_PARSER_PARSING_DECL = "[调试:解析器] 正在解析声明 (当前词法单元: ";
    constexpr const char* DEBUG_PARSER_PARSING_PARAM = "[调试:解析器] 正在解析参数...";
    constexpr const char* DEBUG_PARSER_PARSING_DEFAULT_VAL_FOR = "  正在为 '";
    constexpr const char* DEBUG_PARSER_PARSED_PARAM = "  已解析参数: ";
    constexpr const char* DEBUG_PARSER_WITH_DEFAULT = " (带默认值)";
    constexpr const char* DEBUG_PARSER_PARSING_VAR_DECL = "[调试:解析器] 正在解析变量声明...";
    constexpr const char* DEBUG_PARSER_PARSING_FUNC_DEF = "[调试:解析器] 正在解析函数定义...";
    constexpr const char* DEBUG_PARSER_PARSING_METHOD_DEF = "[调试:解析器] 正在解析方法定义...";
    constexpr const char* DEBUG_PARSER_DONE_PARSING_FUNC = "  完成解析函数 '";
    constexpr const char* DEBUG_PARSER_DONE_PARSING_METHOD = "  完成解析方法 '";
    constexpr const char* DEBUG_PARSER_PARSING_CLASS_DEF = "[调试:解析器] 正在解析类定义...";
    constexpr const char* DEBUG_PARSER_DONE_PARSING_CLASS = "  完成解析类 '";
    constexpr const char* DEBUG_PARSER_PARSING_ASSIGNMENT = "[调试:解析器] 正在解析赋值表达式...";
    constexpr const char* DEBUG_PARSER_PARSING_CALL = "[调试:解析器] 正在解析函数调用...";
    constexpr const char* DEBUG_PARSER_PARSING_SUBSCRIPT = "[调试:解析器] 正在解析下标访问...";
    constexpr const char* DEBUG_PARSER_PARSING_GET = "[调试:解析器] 正在解析属性/方法访问...";
    constexpr const char* DEBUG_INTERP_START = "[调试:解释器] 开始解释 ";
    constexpr const char* DEBUG_INTERP_STATEMENTS = " 条语句。";
    constexpr const char* DEBUG_INTERP_EXEC_TOP_LEVEL = "[调试:解释器] === 正在执行顶层语句 ";
    constexpr const char* DEBUG_INTERP_AT_LINE = " (第 ";
    constexpr const char* DEBUG_INTERP_END_EXEC_STMT = "行) ===";
    constexpr const char* DEBUG_INTERP_DONE = "[调试:解释器] 解释完成。";
    constexpr const char* DEBUG_INTERP_EXEC_STMT_TYPE = "[调试:解释器] 正在执行类型为 ";
    constexpr const char* DEBUG_INTERP_EVAL_EXPR_TYPE = "[调试:解释器] 正在求值类型为 ";
    constexpr const char* DEBUG_INTERP_BLOCK_ENTER = "[调试:解释器] ---> 进入新块/作用域。环境: ";
    constexpr const char* DEBUG_INTERP_BLOCK_PREVIOUS = " 上一个: ";
    constexpr const char* DEBUG_INTERP_BLOCK_EXIT_EXCEPTION = "[调试:解释器] <--- 因异常退出块/作用域。恢复环境到 ";
    constexpr const char* DEBUG_INTERP_BLOCK_EXIT = "[调试:解释器] <--- 退出块/作用域。恢复环境到 ";
    constexpr const char* DEBUG_EXEC_LITERAL_NODE = "[调试:执行] 正在求值 LiteralNode。值: ";
    constexpr const char* DEBUG_EXEC_LIST_LITERAL_NODE = "[调试:执行] 正在求值 ListLiteralNode, 有 ";
    constexpr const char* DEBUG_EXEC_LIST_LITERAL_NODE_ELEMENTS = " 个元素。";
    constexpr const char* DEBUG_EXEC_VAR_NODE = "[调试:执行] 正在求值 VariableNode '";
    constexpr const char* DEBUG_EXEC_ASSIGN_NODE = "[调试:执行] 正在执行 AssignmentNode。要赋的值: ";
    constexpr const char* DEBUG_EXEC_ASSIGN_TARGET_VAR = "  赋值目标是 VariableNode: '";
    constexpr const char* DEBUG_EXEC_ASSIGN_TARGET_SUBSCRIPT = "  赋值目标是 SubscriptNode。";
    constexpr const char* DEBUG_EXEC_ASSIGN_TARGET_GET = "  赋值目标是 GetNode: 属性 '";
    constexpr const char* DEBUG_EXEC_VAR_DECL_NODE_INIT = "[调试:执行] 正在执行 VarDeclarationNode, 变量 '";
    constexpr const char* DEBUG_EXEC_VAR_DECL_NODE_WITH_INIT = "' (带初始化器)。";
    constexpr const char* DEBUG_EXEC_VAR_DECL_NODE_NO_INIT = "' (无初始化器)。";
    constexpr const char* DEBUG_EXEC_VAR_DECL_DECLARED_TYPE = "  声明的类型: ";
    constexpr const char* DEBUG_EXEC_VAR_DECL_INITIAL_VALUE = "。初始值: ";
    constexpr const char* DEBUG_EXEC_VAR_DECL_FINAL_VALUE = "  强制转换后的最终值: ";
    constexpr const char* DEBUG_EXEC_BINARY_OP = "[调试:执行] 正在求值 BinaryOpNode (操作符: ";
    constexpr const char* DEBUG_EXEC_BINARY_OP_LEFT = "  左操作数: ";
    constexpr const char* DEBUG_EXEC_BINARY_OP_RIGHT = ", 右操作数: ";
    constexpr const char* DEBUG_EXEC_SUBSCRIPT_NODE = "[调试:执行] 正在求值 SubscriptNode。";
    constexpr const char* DEBUG_EXEC_SUBSCRIPT_NODE_OBJ = "  对象: ";
    constexpr const char* DEBUG_EXEC_SUBSCRIPT_NODE_IDX = ", 索引: ";
    constexpr const char* DEBUG_EXEC_IF_NODE = "[调试:执行] 正在执行 IfStatementNode。正在求值条件...";
    constexpr const char* DEBUG_EXEC_IF_CONDITION_TRUE = "  条件为真";
    constexpr const char* DEBUG_EXEC_IF_CONDITION_FALSE = "  条件为假";
    constexpr const char* DEBUG_EXEC_IF_CONDITION_VALUE = " (";
    constexpr const char* DEBUG_EXEC_IF_THEN = "  正在执行 'then' 分支。";
    constexpr const char* DEBUG_EXEC_IF_ELSE = "  正在执行 'else' 分支。";
    constexpr const char* DEBUG_EXEC_WHILE_NODE = "[调试:执行] 正在执行 WhileStatementNode。";
    constexpr const char* DEBUG_EXEC_WHILE_CONDITION_TRUE = "  While 循环条件为真";
    constexpr const char* DEBUG_EXEC_WHILE_CONDITION_FALSE = "  While 循环条件为假";
    constexpr const char* DEBUG_EXEC_WHILE_FINALLY = "  正在执行 while 循环的 'finally' 分支。";
    constexpr const char* DEBUG_EXEC_AWAIT_NODE = "[调试:执行] 正在执行 AwaitStatementNode。等待条件...";
    constexpr const char* DEBUG_EXEC_AWAIT_SATISFIED = "  Await 条件满足。正在执行 'then' 分支。";
    constexpr const char* DEBUG_EXEC_SAY_NODE = "[调试:执行] 正在执行 SayNode。";
    constexpr const char* DEBUG_EXEC_SAY_VALUE = "  要输出的值: ";
    constexpr const char* DEBUG_EXEC_FUNC_DEF_NODE = "[调试:执行] 正在执行 FunctionDefNode, 函数 '";
    constexpr const char* DEBUG_EXEC_CLASS_DEF_NODE = "[调试:执行] 正在执行 ClassDefNode, 类 '";
    constexpr const char* DEBUG_EXEC_CLASS_DEF_PROCESSING_METHOD = "  正在处理方法 '";
    constexpr const char* DEBUG_EXEC_GET_NODE = "[调试:执行] 正在求值 GetNode, 属性 '";
    constexpr const char* DEBUG_EXEC_GET_NODE_OBJECT_EVAL = "  对象求值结果: ";
    constexpr const char* DEBUG_EXEC_CALL_NODE = "[调试:执行] 正在执行 CallNode (第 ";
    constexpr const char* DEBUG_EXEC_CALL_NODE_EVAL_CALLEE = "行)。正在求值被调用者...";
    constexpr const char* DEBUG_EXEC_CALL_NODE_CALLEE_EVAL = "  被调用者求值结果: ";
    constexpr const char* DEBUG_EXEC_CALL_NODE_EVAL_ARGS = "  正在求值 ";
    constexpr const char* DEBUG_EXEC_CALL_NODE_ARGS = " 个参数...";
    constexpr const char* DEBUG_EXEC_CALL_NODE_NATIVE = "  正在调用原生函数 '";
    constexpr const char* DEBUG_EXEC_CALL_NODE_USER = "  正在调用用户函数 '";
    constexpr const char* DEBUG_EXEC_CALL_NODE_BINDING_ARGS = "    正在绑定 ";
    constexpr const char* DEBUG_EXEC_CALL_NODE_ARGS_TO = " 个参数到 ";
    constexpr const char* DEBUG_EXEC_CALL_NODE_PARAMS = " 个形参 (";
    constexpr const char* DEBUG_EXEC_CALL_NODE_REQUIRED = " 个必需)。";
    constexpr const char* DEBUG_EXEC_CALL_NODE_BINDING_PARAM = "      正在绑定形参 '";
    constexpr const char* DEBUG_EXEC_CALL_NODE_TO_ARG = "' 到实参 ";
    constexpr const char* DEBUG_EXEC_CALL_NODE_PUSH_STACK = "    正在将 '";
    constexpr const char* DEBUG_EXEC_CALL_NODE_TO_STACK = "' 推入调用栈。";
    constexpr const char* DEBUG_EXEC_CALL_NODE_POP_STACK = "    正在从调用栈弹出 '";
    constexpr const char* DEBUG_EXEC_CALL_NODE_FROM_STACK = "'。返回值: ";
    constexpr const char* DEBUG_EXEC_CALL_NODE_BOUND_METHOD = "  正在调用绑定方法 '";
    constexpr const char* DEBUG_EXEC_CALL_NODE_ON_INSTANCE = "' 在实例 ";
    constexpr const char* DEBUG_EXEC_CALL_NODE_DEFINE_THIS = "    正在方法作用域中定义 'this'。";
    constexpr const char* DEBUG_EXEC_RETURN_NODE = "[调试:执行] 正在执行 ReturnNode。抛出 ReturnValueException, 值为 ";
    constexpr const char* DEBUG_EXEC_RAISE_NODE = "[调试:执行] 正在执行 RaiseNode。抛出 PyRiteRaiseException, 负载为 ";
    constexpr const char* DEBUG_EXEC_TRY_NODE = "[调试:执行] 正在执行 TryCatchNode。进入 'try' 块。";
    constexpr const char* DEBUG_EXEC_TRY_CAUGHT_PYRITE = "  在 'try' 块中捕获到 PyRiteRaiseException。负载: ";
    constexpr const char* DEBUG_EXEC_TRY_EXEC_CATCH = "。正在执行 'catch' 块。";
    constexpr const char* DEBUG_EXEC_TRY_CAUGHT_RUNTIME = "  在 'try' 块中捕获到 RuntimeError: ";
    constexpr const char* DEBUG_EXEC_TRY_CAUGHT_UNEXPECTED = "  在 'catch' 块中捕获到意外异常。它将在 'finally' 后被重新抛出。";
    constexpr const char* DEBUG_EXEC_TRY_EXEC_FINALLY = "  正在执行 'finally' 块。";
    constexpr const char* DEBUG_EXEC_TRY_RETHROWING = "  正在从 'catch' 块重新抛出异常。";
    constexpr const char* DEBUG_EXEC_TRY_DONE = "  TryCatchNode 执行完成。";
    constexpr const char* DEBUG_EXEC_EXPR_STMT_NODE = "[调试:执行] 正在执行 ExpressionStatementNode。";
    constexpr const char* DEBUG_INSTANCE_CREATING = "[调试:实例] 正在创建 '";
    constexpr const char* DEBUG_INSTANCE_NEW_ENV = "' 的实例。正在创建新环境, 外层环境为 ";
    constexpr const char* DEBUG_INSTANCE_INIT_FIELD = "  正在初始化字段 '";
    constexpr const char* DEBUG_INSTANCE_WITH_DEFAULT = "' 使用默认值 ";
    constexpr const char* DEBUG_INSTANCE_GET_PROP = "[调试:实例] 正在获取属性 '";
    constexpr const char* DEBUG_INSTANCE_FROM = "' 从 '";
    constexpr const char* DEBUG_INSTANCE_CHECK_FIELDS = "' 的实例。  正在检查实例字段...";
    constexpr const char* DEBUG_INSTANCE_PROP_NOT_IN_FIELDS = "  属性 '";
    constexpr const char* DEBUG_INSTANCE_CHECK_METHODS = "' 不在字段中。正在检查类方法...";
    constexpr const char* DEBUG_INSTANCE_FOUND_METHOD = "  找到方法 '";
    constexpr const char* DEBUG_INSTANCE_CREATING_BOUND_METHOD = "'。正在创建绑定方法。";
    constexpr const char* DEBUG_INSTANCE_SET_PROP = "[调试:实例] 正在设置属性 '";
    constexpr const char* DEBUG_INSTANCE_FOR = "' 对于 '";
    constexpr const char* DEBUG_INSTANCE_TO_VALUE = "' 的实例, 值为 ";
    constexpr const char* DEBUG_INSTANCE_FOUND_FIELD = "  找到字段 '";
    constexpr const char* DEBUG_INSTANCE_TYPE_CHECKING = "'。正在进行类型检查... 期望: ";
    constexpr const char* DEBUG_INSTANCE_TYPE_CHECK_OK = "  类型检查通过。正在设置字段值。";

    // --- REPL 与 Main ---
    constexpr const char* REPL_WELCOME_BANNER_1 = "PyRite 解释器 ";
    constexpr const char* REPL_WELCOME_BANNER_DEBUG = " [调试模式]";
    constexpr const char* REPL_WELCOME_BANNER_2 = "。\n";
    constexpr const char* REPL_WELCOME_BANNER_3 = "输入 'run()' 执行缓冲代码, 'compile()' 进行编译, 'halt()' 退出, 'about()' 查看版本信息。\n";
    constexpr const char* REPL_HALTED = "解释器已停止。";
    constexpr const char* REPL_NO_CODE_TO_RUN = "没有可执行的代码。";
    constexpr const char* REPL_TICK_ARG_ERROR = "[运行时错误] run() 的 'tick' 参数必须是布尔值 (0/1, false/true)。";
    constexpr const char* REPL_LIMIT_ARG_ERROR_LITERAL = "[运行时错误] run() 的 'limit' 参数必须是数字字面量。";
    constexpr const char* REPL_LIMIT_ARG_ERROR_INVALID = "[运行时错误] run() 的 'limit' 参数无效。";
    constexpr const char* REPL_EXECUTION_TIME_PREFIX = "代码执行时间: ";
    constexpr const char* REPL_EXECUTION_TIME_SUFFIX = "毫秒。";
    constexpr const char* ABOUT_HEADER_FOOTER = "----------------------------------------\n";
    constexpr const char* ABOUT_LINE_1 = " PyRite 语言解释器 ";
    constexpr const char* ABOUT_LINE_2 = "\n (c) 2024-2025. DarkstarXD. 保留所有权利。\n";
    constexpr const char* ABOUT_LINE_3 = " 一种简单到神奇的编程语言?!\n";
    constexpr const char* MAIN_USAGE_ERROR = "用法: ";
    constexpr const char* MAIN_USAGE_ERROR_SCRIPT = " [script.src]";
    constexpr const char* MAIN_FILE_OPEN_ERROR = "错误: 无法打开文件 '";

    // --- 编译 ---
    constexpr const char* COMPILE_SYNTAX_ERROR = "语法错误: 调用缺少 '()'。";
    constexpr const char* COMPILE_ARG_SYNTAX_ERROR = "语法错误: 参数必须是 key=value 格式。";
    constexpr const char* COMPILE_ERROR_PREFIX = "[编译错误] ";
    constexpr const char* COMPILE_ERROR_SUFFIX = "。";
    constexpr const char* COMPILE_BUFFER_EMPTY = "缓冲区为空, 无法编译。";
    constexpr const char* COMPILE_CANNOT_OPEN_SOURCE = "无法打开源文件: ";
    constexpr const char* COMPILE_CANNOT_OPEN_TEMPLATE = "无法打开编译器模板文件: ";
    constexpr const char* COMPILE_TEMPLATE_PLACEHOLDER_MISSING = "在 template.cpp 中未找到占位符 WRITE_SRC_CODE_HERE。";
    constexpr const char* COMPILE_TRANSLATION_TARGET = "转换目标: ";
    constexpr const char* COMPILE_CANNOT_OPEN_TEMP_WRITE = "无法打开临时编译文件进行写入 (请检查权限和路径): ";
    constexpr const char* COMPILE_WRITE_TEMP_FAILED = "写入临时编译文件失败 (可能是权限问题或磁盘已满): ";
    constexpr const char* COMPILE_COMMAND_INFO = "使用编译命令: ";
    constexpr const char* COMPILE_SUCCESS_PREFIX = "成功编译 ";
    constexpr const char* COMPILE_SUCCESS_TOOK = " (用时 ";
    constexpr const char* COMPILE_SUCCESS_SECONDS = " 秒) 输出到 ";
    constexpr const char* COMPILE_FAILURE_PREFIX = "编译 ";
    constexpr const char* COMPILE_FAILURE_SUFFIX = " 失败 (编译器错误)";
}

#endif // MESSAGES_HPP
